<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>UNM CS 412/512 HW5 - Texture Mapping</title>
  <style>
    body { background: #111; color: #ccc; font-family: monospace; }
    textarea { background: #222; color: #0f0; font: 14px monospace; width: 400px; height: 250px; }
    canvas { border: 1px solid #444; }
    #controls { margin-top: 15px; padding: 10px; border: 1px solid #444; border-radius: 5px; background: #222; }
    .joint-control { margin-bottom: 10px; padding: 5px; border-left: 3px solid #00ffaa; }
    #controls label, #controls input { margin-right: 10px; margin-bottom: 5px; display: inline-block; }
    #controls input[type="range"] { width: 150px; vertical-align: middle; }
    #lighting-controls { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 10px; }
  </style>
</head>

<body>
  <h2>Robotic Arm - Hierarchical Model - Texture Mapping</h2>
  <p>Use mouse to drag and rotate the scene. Use arrow keys and w, s keys to move the camera.</p>
  <p>Please Move The Shoulder Joint (Level 2) To See The Changes In The Base Joint (Level 1) Rotation.</p>

  <div style="display:flex;gap:10px;align-items:flex-start;">
    <div style="display:flex;flex-direction:column;gap:10px;">
      <div>
        <b>Vertex Shader</b><br>
        <textarea id="vertEditor"></textarea>
      </div>
      <div>
        <b>Fragment Shader</b><br>
        <textarea id="fragEditor"></textarea>
      </div>
    </div>
    <div>
      <canvas id="glcanvas" width="600" height="600"></canvas>
      <div id="controls">
        <div class="joint-control">
          <b>Base Joint (Level 1 Movement)</b>
          <label for="joint1-slider">Y-Rotation:</label>
          <input type="range" id="joint1-slider" data-joint-id="joint1" min="-180" max="180" value="0">
        </div>
        <div class="joint-control">
          <b>Shoulder Joint (Level 2 Movement)</b>
          <label for="joint2-slider">X-Rotation:</label>
          <input type="range" id="joint2-slider" data-joint-id="joint2" min="-15" max="15" value="0">
        </div>
        <div class="joint-control">
          <b>Wrist Joint (Level 3 Movement)</b>
          <label for="joint3-slider">Y-Rotation:</label>
          <input type="range" id="joint3-slider" data-joint-id="joint3" min="-90" max="90" value="0">
        </div>
        </div>
    </div>
  </div>

  <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
in vec3 aPosition;
in vec3 aColor;
in vec3 aNormal; // Reintroduced normal for future lighting
in vec2 aTexCoord; // New texture coordinate attribute

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat4 uModelTransformationMatrix;
uniform mat4 uNormalMatrix; // Reintroduced normal matrix

out vec3 vColor;
out vec2 vTexCoord; // Texture coordinate output

void main() {
  vec4 worldPosition = uModelTransformationMatrix * vec4(aPosition, 1.0);
  gl_Position = uProjectionMatrix * uModelViewMatrix * worldPosition;
  vColor = aColor; 
  vTexCoord = aTexCoord; 
}
</script>

  <script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
precision mediump float;
in vec3 vColor;
in vec2 vTexCoord; // Texture coordinate input

uniform int uObjectIndex;
uniform sampler2D uSampler; // Texture sampler uniform

out vec4 fragColor;

void main() {
  if (uObjectIndex == 0 || uObjectIndex == 2 || uObjectIndex == 4) {
      // Base, Lower Arm, Upper Arm (Cylinders) get texture
      fragColor = texture(uSampler, vTexCoord);
  } else {
      // Joints/Fingers (Spheres/Cones) get flat color for now
      vec3 objectColor;
      if (uObjectIndex == 1)      objectColor = vec3(1.0, 0.5, 0.0); // Orange (Shoulder Joint)
      else if (uObjectIndex == 3) objectColor = vec3(0.0, 1.0, 0.0); // Green (Wrist Joint)
      else if (uObjectIndex == 5) objectColor = vec3(0.5, 0.0, 0.5); // Purple (Finger 1)
      else if (uObjectIndex == 6) objectColor = vec3(0.0, 1.0, 1.0); // Cyan (Finger 2)
      else                        objectColor = vec3(1.0, 1.0, 1.0); // Fallback
      
      fragColor = vec4(objectColor, 1.0);
  }
}
</script>

  <script src="primitives.js"></script>
  <script src="transformations.js"></script>

  <script>
    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error("Shader Compile Error:", gl.getShaderInfoLog(shader));
        return null;
      }
      return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
      const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
      const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      if (!vs || !fs) return null;
      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error("Program Link Error:", gl.getProgramInfoLog(prog));
        return null;
      }
      return prog;
    }

    const canvas = document.getElementById("glcanvas");
    const gl = canvas.getContext("webgl2");
    if (!gl) console.error("WebGL2 not supported");

    const vertEditor = document.getElementById("vertEditor");
    const fragEditor = document.getElementById("fragEditor");
    vertEditor.value = document.getElementById("vertex-shader").textContent;
    fragEditor.value = document.getElementById("fragment-shader").textContent;
    
    let program, posLoc, colorLoc, normalLoc, texCoordLoc, 
        uMVM, uPM, uMTM, uNormalMatrixLoc, uObjectIndexLoc, uSamplerLoc; 

    function initShaderProgram() {
      program = createProgram(gl, vertEditor.value, fragEditor.value);
      if (!program) return;
      gl.useProgram(program);
      posLoc = gl.getAttribLocation(program, "aPosition");
      colorLoc = gl.getAttribLocation(program, "aColor");
      normalLoc = gl.getAttribLocation(program, "aNormal"); 
      texCoordLoc = gl.getAttribLocation(program, "aTexCoord"); 

      uMVM = gl.getUniformLocation(program, "uModelViewMatrix");
      uPM  = gl.getUniformLocation(program, "uProjectionMatrix");
      uMTM = gl.getUniformLocation(program, "uModelTransformationMatrix");
      uNormalMatrixLoc = gl.getUniformLocation(program, "uNormalMatrix"); 
      uObjectIndexLoc = gl.getUniformLocation(program, "uObjectIndex"); 
      uSamplerLoc = gl.getUniformLocation(program, "uSampler"); 
    }
    initShaderProgram();
    vertEditor.onkeyup = initShaderProgram;
    fragEditor.onkeyup = initShaderProgram;

    // --- Texture Management Functions ---

    let textures = {}; 
    let textureReadyCount = 0;
    const TOTAL_TEXTURES = 2; // Now loading two textures
    let imageURLs = {
        'cylinderTexture': 'images/manu.jpg', // Static texture for base (0) and upper arm (4)
        'animatedTexture': 'images/mourinho.gif' // Animated texture for lower arm (2)
    };

    function loadTexture(gl, url, name) {
        const texture = gl.createTexture();
        textures[name] = texture;
        gl.bindTexture(gl.TEXTURE_2D, texture);

        // Fill texture with a temporary solid color (Red) while image loads
        const level = 0;
        const internalFormat = gl.RGBA;
        const width = 1;
        const height = 1;
        const border = 0;
        const srcFormat = gl.RGBA;
        const srcType = gl.UNSIGNED_BYTE;
        const pixel = new Uint8Array([255, 0, 0, 255]); 
        gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, pixel);

        const image = new Image();
        image.onload = () => {
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); 
            gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, image);

            // WebGL 1/2 Check for power-of-2 dimensions
            if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                gl.generateMipmap(gl.TEXTURE_2D);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
            } else {
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            }
            gl.bindTexture(gl.TEXTURE_2D, null); 
            textureReadyCount++;
            if (textureReadyCount === TOTAL_TEXTURES) {
                console.log("All textures loaded.");
            }
        };
        image.onerror = () => {
            console.error(`Failed to load texture: ${url}`);
        };
        image.src = url;
    }
    
    function isPowerOf2(value) {
        return (value & (value - 1)) === 0;
    }
    
    function initializeTextures() {
        loadTexture(gl, imageURLs.cylinderTexture, 'cylinderTexture');
        loadTexture(gl, imageURLs.animatedTexture, 'animatedTexture');
    }
    
    // --- End Texture Management ---

    function createGlObject(gl, positions, colors, normals, texCoords, indices, baseScale=[1,1,1]) { 
      const vbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
      const cbo = gl.createBuffer(); 
      gl.bindBuffer(gl.ARRAY_BUFFER, cbo);
      gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
      const nbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, nbo);
      gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);
      
      const tbo = gl.createBuffer(); 
      gl.bindBuffer(gl.ARRAY_BUFFER, tbo);
      gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
      
      const ibo = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
      
      return { vbo, cbo, nbo, tbo, ibo, indexCount: indices.length, baseScale }; 
    }

    let accumulatedRotationMatrix, proj, startTime;
    let mouseDown = false, lastX, lastY;
    let camX = 0, camY = -2, camZ = -20;
    let sphereData, cylinderData, coneData, rootNode; 
    
    function drawModel(node, parentMTM) {
      if (!node.object || !node.object.vbo) return;
      
      // Select Texture based on index
      if (node.index === 0 || node.index === 4) {
          // Base (0) and Upper Arm (4) use static texture
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, textures['cylinderTexture']);
          gl.uniform1i(uSamplerLoc, 0); 
      } else if (node.index === 2) {
          // Lower Arm (2) uses animated texture
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, textures['animatedTexture']);
          gl.uniform1i(uSamplerLoc, 0); 
      }
      
      let LTM = mat4Identity();
      LTM = mat4Scale(LTM, node.object.baseScale);
      if (node.rotation) {
        if (node.rotation.axis === 'X') LTM = mat4RotateX(LTM, node.rotation.angle);
        if (node.rotation.axis === 'Y') LTM = mat4RotateY(LTM, node.rotation.angle);
        if (node.rotation.axis === 'Z') LTM = mat4RotateZ(LTM, node.rotation.angle);
      }
      LTM = mat4Translate(LTM, node.translation || [0,0,0]);
      const MTM = multiplyMat4(parentMTM, LTM);
      
      const NTM = mat4InverseTranspose(MTM); 
      gl.uniformMatrix4fv(uNormalMatrixLoc, false, NTM); 

      gl.uniform1i(uObjectIndexLoc, node.index);
      gl.uniformMatrix4fv(uMTM, false, MTM);
      const obj = node.object;
      
      gl.bindBuffer(gl.ARRAY_BUFFER, obj.vbo);
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
      
      gl.bindBuffer(gl.ARRAY_BUFFER, obj.cbo);
      gl.enableVertexAttribArray(colorLoc);
      gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);
      
      gl.bindBuffer(gl.ARRAY_BUFFER, obj.nbo); 
      gl.enableVertexAttribArray(normalLoc);
      gl.vertexAttribPointer(normalLoc, 3, gl.FLOAT, false, 0, 0);
      
      gl.bindBuffer(gl.ARRAY_BUFFER, obj.tbo); 
      gl.enableVertexAttribArray(texCoordLoc);
      gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 0, 0);

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibo);
      gl.drawElements(gl.TRIANGLES, obj.indexCount, gl.UNSIGNED_SHORT, 0);
      
      if (node.children) node.children.forEach(child => drawModel(child, MTM));
    }

    function render(currentTime) {
      if (!program) return;
      gl.enable(gl.DEPTH_TEST);
      gl.clearColor(0.1, 0.1, 0.1, 1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      
      const viewRotationMatrix = multiplyMat4(mat4Translate(mat4Identity(), [camX, camY, camZ]), accumulatedRotationMatrix);
      
      gl.uniformMatrix4fv(uPM, false, proj);
      gl.uniformMatrix4fv(uMVM, false, viewRotationMatrix);
      
      // Draw the main robot arm
      drawModel(rootNode, mat4Identity()); 
      
      requestAnimationFrame(render);
    }

    window.onload = function () {
      accumulatedRotationMatrix = mat4Identity();
      proj = perspective(Math.PI/4, canvas.width/canvas.height, 0.1, 100);
      startTime = performance.now();
      
      initializeTextures(); // Load the textures

      const BASE_HEIGHT=1.0, SEG_LENGTH=2.0, SEG_THICKNESS=0.5, JOINT_RADIUS=0.8, FINGER_LENGTH=2.0, FINGER_THICKNESS=0.3;
      sphereData = generateSphereData(20,20,1.0);
      cylinderData = generateCylinderData(24,1.0,1.0);
      coneData = generateConeData(24,1.0,1.0);

      const emptyTexCoords = new Float32Array([]);

      const baseObj = createGlObject(gl,cylinderData.positions,cylinderData.colors,cylinderData.normals,cylinderData.texCoords,cylinderData.indices,[4.0,BASE_HEIGHT,4.0]);
      const shoulderJointObj = createGlObject(gl,sphereData.positions,sphereData.colors,sphereData.normals,emptyTexCoords,sphereData.indices,[JOINT_RADIUS,JOINT_RADIUS,JOINT_RADIUS]); 
      const lowerArmObj = createGlObject(gl,cylinderData.positions,cylinderData.colors,cylinderData.normals,cylinderData.texCoords,cylinderData.indices,[SEG_THICKNESS,SEG_LENGTH,SEG_THICKNESS]);
      const elbowJointObj = createGlObject(gl,sphereData.positions,sphereData.colors,sphereData.normals,emptyTexCoords,sphereData.indices,[JOINT_RADIUS*0.8,JOINT_RADIUS*0.8,JOINT_RADIUS*0.8]); 
      const upperArmObj = createGlObject(gl,cylinderData.positions,cylinderData.colors,cylinderData.normals,cylinderData.texCoords,cylinderData.indices,[SEG_THICKNESS,SEG_LENGTH,SEG_THICKNESS]);
      const finger1Obj = createGlObject(gl,coneData.positions,coneData.colors,coneData.normals,coneData.texCoords,coneData.indices,[FINGER_THICKNESS,FINGER_LENGTH,FINGER_THICKNESS]);
      const finger2Obj = createGlObject(gl,coneData.positions,coneData.colors,coneData.normals,coneData.texCoords,coneData.indices,[FINGER_THICKNESS,FINGER_LENGTH,FINGER_THICKNESS]);

      const finger1Node = {object:finger1Obj,index:5,translation:[0,FINGER_LENGTH*0.25,FINGER_THICKNESS/2],rotation:{axis:'Z',angle:0}};
      const finger2Node = {object:finger2Obj,index:6,translation:[0,FINGER_LENGTH*0.25,-FINGER_THICKNESS/2],rotation:{axis:'Z',angle:0}};
      const upperArmNode = {object:upperArmObj,index:4,translation:[0,SEG_LENGTH*0.5,0],rotation:{axis:'X',angle:0},children:[finger1Node,finger2Node]};
      const wristJointNode = {object:elbowJointObj,index:3,translation:[0,SEG_LENGTH*0.5,0],rotation:{axis:'Y',angle:0,jointId:'joint3'},children:[upperArmNode]};
      const lowerArmNode = {object:lowerArmObj,index:2,translation:[0,SEG_LENGTH*0.5,0],rotation:{axis:'X',angle:0,jointId:'joint2'},children:[wristJointNode]};
      const shoulderJointNode = {object:shoulderJointObj,index:1,translation:[0,BASE_HEIGHT*0.5,0],rotation:{axis:'Y',angle:0,jointId:'joint1'},children:[lowerArmNode]};
      rootNode = {object:baseObj,index:0,translation:[0,BASE_HEIGHT*0.5-5.0,0],children:[shoulderJointNode]};
      
      document.querySelectorAll('#controls input[type="range"]').forEach(s=>{
        s.addEventListener('input',e=>{
          const a=parseFloat(e.target.value)*Math.PI/180;
          const id=e.target.dataset.jointId;
          const u=n=>{if(n.rotation&&n.rotation.jointId===id)n.rotation.angle=a;if(n.children)n.children.forEach(u);};
          u(rootNode);
        });
      });
      
      canvas.addEventListener('mousedown',e=>{mouseDown=true;lastX=e.clientX;lastY=e.clientY;});
      canvas.addEventListener('mouseup',()=>mouseDown=false);
      canvas.addEventListener('mousemove',e=>{
        if(!mouseDown)return;
        const dx=e.clientX-lastX,dy=e.clientY-lastY;
        const rot= multiplyMat4(mat4RotateY(mat4RotateX(mat4Identity(),dy*0.01),dx*0.01),accumulatedRotationMatrix);
        accumulatedRotationMatrix=rot;
        lastX=e.clientX;lastY=e.clientY;
      });

      document.addEventListener('keydown',e=>{
        const s=0.5;
        if(e.key==='ArrowUp')camY+=s;
        if(e.key==='ArrowDown')camY-=s;
        if(e.key==='ArrowLeft')camX-=s;
        if(e.key==='ArrowRight')camX+=s;
        if(e.key==='w')camZ+=s;
        if(e.key==='s')camZ-=s;
      });

      requestAnimationFrame(render);
    };
  </script>
</body>
</html>